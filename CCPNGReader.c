// Author: Jonathan Decker
// Description: simple PNG reader/writer using miniz.c
// Simple min sum filtering scheming as defined by PNG spec

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#ifdef CCPNG_STANDALONE
#ifdef _WIN32
//#include <vld.h>
#endif
#endif

#include "CCPNGReader.h"

#ifdef _WIN32
#include "miniz.c"
#else
#include "External/miniz.c"
#endif

// Edit : From miniz source, but modified to include a filter parameter
// Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
// This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck.
void *tdefl_write_image_to_png_file_in_memory_filters_ex(const void *pImage, mz_uint8* filters, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
{
  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined.
  static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };
  tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor)); tdefl_output_buffer out_buf; int i, bpl = w * num_chans, y, z; mz_uint32 c; mz_uint8 t = 0; *pLen_out = 0;
  if (!pComp) return NULL;
  MZ_CLEAR_OBJ(out_buf); out_buf.m_expandable = MZ_TRUE; out_buf.m_capacity = 57+MZ_MAX(64, (1+bpl)*h); if (NULL == (out_buf.m_pBuf = (mz_uint8*)MZ_MALLOC(out_buf.m_capacity))) { MZ_FREE(pComp); return NULL; }
  // write dummy header
  for (z = 41; z; --z) tdefl_output_buffer_putter(&z, 1, &out_buf);
  // compress image data
  tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
  for (y = 0; y < h; ++y) { tdefl_compress_buffer(pComp, filters == NULL ? &t : filters+(flip ? (h - 1 - y) : y), 1, TDEFL_NO_FLUSH); tdefl_compress_buffer(pComp, (mz_uint8*)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH); }
  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE) { MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }
  // write real header
  *pLen_out = out_buf.m_size-41;
  {
    static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};
    mz_uint8 pnghdr[41]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a,0x00,0x00,0x00,0x0d,0x49,0x48,0x44,0x52,
      0,0,(mz_uint8)(w>>8),(mz_uint8)w,0,0,(mz_uint8)(h>>8),(mz_uint8)h,8,chans[num_chans],0,0,0,0,0,0,0,
      (mz_uint8)(*pLen_out>>24),(mz_uint8)(*pLen_out>>16),(mz_uint8)(*pLen_out>>8),(mz_uint8)*pLen_out,0x49,0x44,0x41,0x54};
    c=(mz_uint32)mz_crc32(MZ_CRC32_INIT,pnghdr+12,17); for (i=0; i<4; ++i, c<<=8) ((mz_uint8*)(pnghdr+29))[i]=(mz_uint8)(c>>24);
    memcpy(out_buf.m_pBuf, pnghdr, 41);
  }
  // write footer (IDAT CRC-32, followed by IEND chunk)
  if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf)) { *pLen_out = 0; MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }
  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT,out_buf.m_pBuf+41-4, *pLen_out+4); for (i=0; i<4; ++i, c<<=8) (out_buf.m_pBuf+out_buf.m_size-16)[i] = (mz_uint8)(c >> 24);
  // compute final size of file, grab compressed data buffer and return
  *pLen_out += 57; MZ_FREE(pComp); return out_buf.m_pBuf;
}

void *tdefl_write_image_to_png_file_in_memory_filters(const void *pImage, mz_uint8* filters, int w, int h, int num_chans, size_t *pLen_out)
{
  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out)
  return tdefl_write_image_to_png_file_in_memory_filters_ex(pImage, filters, w, h, num_chans, pLen_out, 6, MZ_FALSE);
}

typedef enum ccpngct
{
	CCPNG_GRAYSCALE = 0,
	CCPNG_IDXGRAYSCALE,
	CCPNG_TRUECOLOR,
	CCPNG_IDX,
	CCPNG_GRAYALPHA,
	CCPNG_IDXGRAYALPHA,
	CCPNG_TRUEALPHA,
	CCPNG_IDXALPHA
}ccpng_color_type;

typedef enum ccpngfilter
{
	CCPNG_NONE = 0,
	CCPNG_SUB,
	CCPNG_UP,
	CCPNG_AVG,
	CCPNG_PAETH,
}ccpng_filter_type;

static const unsigned char expectedHeader[8] = {0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a};

typedef struct ccpnginternal
{
	unsigned int   _reserveLength;
	unsigned int   _currLength;

	mz_uint8* _chunkCache;
	mz_uint8* _dataCache;
	mz_uint8* _imageCache;

	unsigned int _currDataCachePosition;
	unsigned int _dataCacheReserveSize;

	unsigned int _currImageCachePosition;
	unsigned int _imageCacheReserveSize;

}CCPNGInternal;

static CCPNGInternal* pccpng = NULL;

#ifndef _WIN32
static unsigned int swap_endian(unsigned int u)
{
	size_t k;
    union
    {
        unsigned int u;
        unsigned char u8[4];
    } source, dest;

    source.u = u;

    for(k = 0; k < 4; k++)
        dest.u8[k] = source.u8[4 - k - 1];

    return dest.u;
}
#endif

void CCPNGInit()
{
	if( pccpng == NULL )
	{
		pccpng = (CCPNGInternal*)malloc(sizeof(CCPNGInternal));

		pccpng->_chunkCache = NULL;
		pccpng->_dataCache = NULL;
		pccpng->_imageCache = NULL;
		
		pccpng->_currLength = 0;
		pccpng->_reserveLength = 0;

		pccpng->_currDataCachePosition = 0;
		pccpng->_dataCacheReserveSize = 0;
		
		pccpng->_currImageCachePosition = 0;
		pccpng->_imageCacheReserveSize = 0;
	}
}

void CCPNGDestroy()
{
	if( pccpng != NULL )
	{
		if( pccpng->_chunkCache != NULL ) 
			free(pccpng->_chunkCache);
		if( pccpng->_dataCache != NULL )
			free(pccpng->_dataCache);
		if( pccpng->_imageCache != NULL )
			free(pccpng->_imageCache);
		free(pccpng);
		pccpng = NULL;
	}
}

static void concat_buffer(mz_uint8** pDst, unsigned int* dstLength, unsigned int* dstReserveLength, const mz_uint8* pSrc, const unsigned int srcLength )
{
	unsigned int endPosition = *dstLength + srcLength;
	mz_uint8* tempImageCache = NULL;
	unsigned int newSize;

	if( *pDst == NULL )
	{
		*dstLength = 0;
		*dstReserveLength = endPosition;
		*pDst = (mz_uint8*)MZ_MALLOC(sizeof(mz_uint8)**dstReserveLength);
	}

	if( endPosition > *dstReserveLength )
	{
		newSize = endPosition*2;
		tempImageCache = (mz_uint8*)MZ_MALLOC(sizeof(mz_uint8)*newSize);

		if( tempImageCache == NULL )
			exit(-1);
		
		memcpy(tempImageCache,*pDst, *dstLength*sizeof(mz_uint8));

		free(*pDst);
		*dstReserveLength = newSize;
		*pDst = tempImageCache;
	}

	memcpy(*pDst+*dstLength, pSrc, srcLength*sizeof(mz_uint8));

	*dstLength = endPosition;
}

static int tinfl_put_buf_func(const void* pBuf, int len, void *pUser)
{
	concat_buffer(&pccpng->_imageCache, &pccpng->_currImageCachePosition, &pccpng->_imageCacheReserveSize, (mz_uint8*)pBuf, len);

    return MZ_TRUE;
}

int CCPNGPaethPredictor(int a, int b, int c)
{
	int Pr;
	int pa, pb, pc;
	int p;
	p = a + b - c;
	pa = abs(p - a);
	pb = abs(p - b);
	pc = abs(p - c);
	if( pa <= pb && pa <= pc ) Pr = a;
	else if( pb <= pc ) Pr = b;
	else Pr = c;
	return Pr;
}

void CCPNGReconstructImage( mz_uint8* data, int width, int height, int channels )
{
	// filtering  
			
	//  c | b
	//  -----
	//  a | x

	unsigned int offset;
	unsigned char filterFunction;
	int a,b,c,n;
	int i,j,k;
	int x;

	mz_uint8 *pA, *pB, *pC, *pX;

	offset = 0;
	n = width*channels+1;

	for( i = 0; i < height; ++i )
	{
		// get filter function
		filterFunction = data[offset];

		offset++;
		for( j = 0; j < width; ++j )
		{
			// recon(a)
			if( j == 0 ) pA = NULL;
			else pA = &data[offset-channels];
					 
			// recon(b)
			if( i == 0 ) pB = NULL;
			else pB = &data[offset-n];

			// recon(c)
			if( j == 0 || i == 0 ) pC = NULL;
			else pC = &data[offset-n-channels];

			// filt(x)
			pX = &data[offset];

			for( k = 0; k < channels; ++k, ++offset )
			{
				x = (int)pX[k];

				a = pA == NULL ? 0 : (int)pA[k];
				b = pB == NULL ? 0 : (int)pB[k];
				c = pC == NULL ? 0 : (int)pC[k];

				switch( filterFunction )
				{
				case CCPNG_SUB:
					x = x+a;
					break;
				case CCPNG_UP:
					x = x+b;
					break;
				case CCPNG_AVG:
					x = x + ((a + b) >> 1 );
					break;
				case CCPNG_PAETH:
					x = x + CCPNGPaethPredictor(a,b,c);
					break;
				case CCPNG_NONE:
				default:
					// no action recon(x) = filt(x)
					break;
				}

				x = x % 256;
				pX[k] = x;

			}
		}
	}
}

void CCPNGFilterImage( mz_uint8* data, mz_uint8* filters, int width, int height, int channels )
{
	// filtering  
			
	//  c | b
	//  -----
	//  a | x

	unsigned int offset;
	unsigned char filterFunction;
	unsigned char bestFilterFunction = 0;

	int sum;
	int minSum;

	int a,b,c,n;
	int i,j,k;
	int x;

	mz_uint8 *pA, *pB, *pC;
	mz_uint8 *pX, *pFiltX;

	mz_uint8* filt = NULL;

	unsigned int cb = 0;

	n = width*channels;

	filt = (mz_uint8*)malloc(sizeof(mz_uint8)*n*2);

	for( i = height-1; i >= 0; --i )
	{
		// determine best filter function
		bestFilterFunction = 0;
		minSum = INT_MAX;

		for( filterFunction = 0; filterFunction < 5; ++filterFunction )
		{
			offset = (i+1)*n-channels; // last pixel in row
			sum = 0;
			for( j = width-1; j >= 0; --j )
			{
				// orig(a)
				if( j == 0 ) pA = NULL;
				else pA = &data[offset-channels];
					 
				// orig(b)
				if( i == 0 ) pB = NULL;
				else pB = &data[offset-n];

				// orig(c)
				if( j == 0 || i == 0 ) pC = NULL;
				else pC = &data[offset-n-channels];

				// filt(x)
				pX = &data[offset];

				if( filterFunction )
					pFiltX = &filt[n*cb+j*channels];

				for( k = channels-1; k >= 0; --k, --offset )
				{
					x = (int)pX[k];

					if( filterFunction )
					{

						a = pA == NULL ? 0 : (int)pA[k];
						b = pB == NULL ? 0 : (int)pB[k];
						c = pC == NULL ? 0 : (int)pC[k];

						switch( filterFunction )
						{
						case CCPNG_SUB:
							x = x-a;
							break;
						case CCPNG_UP:
							x = x-b;
							break;
						case CCPNG_AVG:
							x = x - ((a + b) >> 1);
							break;
						case CCPNG_PAETH:
							x = x - CCPNGPaethPredictor(a,b,c);
							break;
						}

						if( x < 0 ) x += 256;
						pFiltX[k] = x;
					}

					sum += x;
				}
			}

			if( sum < minSum )
			{
				minSum = sum;
				bestFilterFunction = filterFunction;
				cb = 1-cb; // swap buffers
			}
		}

		filters[i] = bestFilterFunction;

		if( bestFilterFunction )
			memcpy(data+i*n,filt+n*(1-cb),sizeof(mz_uint8)*n); // copy stored buffer to row
	}

	free(filt);
}

unsigned int* CCPNGReadFile(const char* filename, unsigned int* width, unsigned int* height)
{
	FILE* fptr = NULL;
	unsigned char header[8];
	
	int i, j;
	unsigned int length;
	unsigned char chunk_type[5] = "NONE";
	mz_ulong crc;
	mz_ulong refcrc;

	unsigned char bitsPerChannel;
	unsigned char colorType;
	unsigned char compressionMethod;
	unsigned char filterMethod;
	unsigned char interlaceMethod;

	unsigned int* data = NULL;
	size_t retSize;
	int channels;

	unsigned int offset;
	unsigned int imgOffset;

	int iWidth;
	int iHeight;

	size_t stLength;

	int success = MZ_TRUE;
	int gotHeader = MZ_FALSE;
	int isFirst = MZ_TRUE;

	ccpng_color temp;

	int size;

#ifdef CCPNG_STANDALONE
	printf("Reading file %s...\n", filename);
#endif

#ifdef _WIN32
	fopen_s(&fptr, filename, "rb");
#else
	fptr = fopen(filename, "rb");
#endif
	pccpng->_currImageCachePosition = 0;
	pccpng->_currDataCachePosition = 0;

	if( fptr != NULL )
	{
		fread(header, sizeof(unsigned char), 8, fptr);

#ifdef CCPNG_STANDALONE
		for(i = 0; i < 8; ++i) printf("%02x ",header[i]);
		printf("\n");
#endif

		if( strncmp( (char*)header, (char*)expectedHeader, 8 ) == 0 )
		{
#ifdef CCPNG_STANDALONE
			printf("PNG Header found...\n");
#endif
			while( !feof(fptr) && strncmp((char*)chunk_type,"IEND",4) != 0 )
			{
				retSize = fread((void*)&length, sizeof(unsigned char), 4, fptr);
				retSize += fread(chunk_type, sizeof(unsigned char), 4, fptr);

				if( retSize != 8 )
				{
#ifdef CCPNG_STANDALONE
					printf("Error: received %u bytes, expected %u\n", retSize, 5U);
#endif
					success = MZ_FALSE;
					break;
				}
#ifdef _WIN32
				length = _byteswap_ulong(length);
#else
				length = swap_endian(length);
#endif
				crc = mz_crc32(MZ_CRC32_INIT, (unsigned char*)&chunk_type, 4);

				if( length > 0 ) 
				{
					if( pccpng->_reserveLength < length )
					{
						free(pccpng->_chunkCache);
						pccpng->_chunkCache = NULL;
					}

					if( pccpng->_chunkCache == NULL )
					{
						pccpng->_reserveLength = length;
						pccpng->_currLength = length;
						pccpng->_chunkCache = (mz_uint8*)malloc(sizeof(mz_uint8)*pccpng->_currLength);
					}
					
					retSize = fread(pccpng->_chunkCache, sizeof(mz_uint8), length, fptr);

					pccpng->_currLength = length;

					if( retSize != length )
					{
#ifdef CCPNG_STANDALONE
						printf("Error: incorrect number of bytes read\n");
#endif
						success = MZ_FALSE;
						break;
					}

					crc = mz_crc32(crc, pccpng->_chunkCache, length);
				}

				retSize = fread((void*)&refcrc, sizeof(unsigned char), 4, fptr);

#ifdef _WIN32
				refcrc = _byteswap_ulong(refcrc);
#else
				refcrc = swap_endian(refcrc);
#endif

				if( crc != refcrc )
				{
#ifdef CCPNG_STANDALONE
					printf("Error CRC failed\n");
#endif
					success = MZ_FALSE;
					break;
				}
#ifdef CCPNG_STANDALONE
				printf("Chunk: Length %5u Type %s\n", length, chunk_type);
#endif
				if( strncmp((char*)chunk_type,"IHDR",4) == 0 )
				{
					*width = *((unsigned int*)pccpng->_chunkCache);
					*height = *((unsigned int*)(pccpng->_chunkCache+4));

					bitsPerChannel = *((unsigned int*)(pccpng->_chunkCache+8)); 
					colorType = *((unsigned int*)(pccpng->_chunkCache+9)); 
					compressionMethod = *((unsigned int*)(pccpng->_chunkCache+10)); 
					filterMethod = *((unsigned int*)(pccpng->_chunkCache+11)); 
					interlaceMethod = *((unsigned int*)(pccpng->_chunkCache+12)); 

#ifdef _WIN32
					*width = _byteswap_ulong(*width);
					*height = _byteswap_ulong(*height);
#else
					*width = swap_endian(*width);
					*height = swap_endian(*height);
#endif
					iWidth = *width;
					iHeight = *height;

#ifdef CCPNG_STANDALONE
					printf("Width %u Height %u\nbits per channel: %u\ncolor type: %u\n", 
						   *width, *height, bitsPerChannel, colorType);
#endif
					gotHeader = MZ_TRUE;

					if( *width > 0 && *height > 0 && bitsPerChannel == 8 &&
						compressionMethod + filterMethod + interlaceMethod == 0 )
					{
						if( colorType != CCPNG_TRUECOLOR && colorType != CCPNG_TRUEALPHA && colorType != CCPNG_GRAYALPHA )
						{
							// unsupported
							success = MZ_FALSE;
						}
					}
					else
					{
#ifdef CCPNG_STANDALONE
						printf("Error: Degenerate dimensions\n");
#endif
						success = MZ_FALSE;
					}
				}
				else if( strncmp((char*)chunk_type,"IDAT",4) == 0 )
				{
					concat_buffer(&pccpng->_dataCache, &pccpng->_currDataCachePosition, &pccpng->_dataCacheReserveSize, pccpng->_chunkCache, length);
				}
#ifdef CCPNG_STANDALONE
				else if( strncmp((char*)chunk_type,"tEXt",4) == 0 )
				{
					char* keyword = (char*)pccpng->_chunkCache;
					size_t  keyword_length = strlen(keyword);

					char* text = (char*)pccpng->_chunkCache+keyword_length+1;

					char* textBuffer = (char*)malloc(sizeof(char)*length);

					strncpy(textBuffer,text,length-keyword_length-1);

					textBuffer[length-keyword_length-1] = 0;

					printf("keyword: %s\n", keyword);
					printf("text   : %s\n", textBuffer);

					free(textBuffer);
				}
				else if( strncmp((char*)chunk_type,"iTXt",4) == 0 )
				{
					char* keyword = (char*)pccpng->_chunkCache;
					size_t  keyword_length = strlen(keyword);

					printf("keyword: %s\n", keyword);
				}
#endif
				if( isFirst && !gotHeader )
				{
					success = MZ_FALSE;
					break;
				}

				isFirst = MZ_FALSE;
			}
		}
#ifdef CCPNG_STANDALONE
		else
		{
			printf("Error: Unexpected header...\n");
		}
#endif 
		fclose(fptr);
	}
	else
	{
		success = MZ_FALSE;
	}

	if( success == MZ_TRUE )
	{
		size = *width * *height;
		if( colorType == CCPNG_TRUEALPHA )
			channels = 4;
		else if( colorType == CCPNG_TRUECOLOR )
			channels = 3;
		else // CCPNG_GRAYALPHA
			channels = 2;

		// decompress image
		stLength = pccpng->_currDataCachePosition+1;
		tinfl_decompress_mem_to_callback(pccpng->_dataCache, &stLength, tinfl_put_buf_func, NULL, TINFL_FLAG_PARSE_ZLIB_HEADER);

		if( pccpng->_currImageCachePosition == (unsigned int)size*channels + *height )
		{
#ifdef CCPNG_STANDALONE
			printf("Size of buffer %u\n", pccpng->_currImageCachePosition);
#endif 

            CCPNGReconstructImage(pccpng->_imageCache,iWidth,iHeight,channels);

			data = (unsigned int*)malloc(sizeof(unsigned int) * size);

			offset = 0;
			imgOffset = 0;
			for( i = 0; i < iHeight; ++i )
			{
				// skip filter function
				offset++;
				for( j = 0; j < iWidth; ++j, offset += channels )
				{
					if( colorType == CCPNG_GRAYALPHA )
					{
						temp.r = pccpng->_imageCache[offset+0];
						temp.g = temp.r;
						temp.b = temp.r;
						temp.a = pccpng->_imageCache[offset+1];
					}
					else
					{
						temp.r = pccpng->_imageCache[offset+0];
						temp.g = pccpng->_imageCache[offset+1];
						temp.b = pccpng->_imageCache[offset+2];
				
						if( colorType == CCPNG_TRUEALPHA )
							temp.a = pccpng->_imageCache[offset+3];
						else temp.a = 255;
					}

					data[imgOffset++] = temp.c;
				}
			}
		}
	}

	return data;
}

void CCPNGWriteFile(const char* filename, unsigned int* data, const unsigned int width, const unsigned int height, const int alpha, const int filter)
{
	size_t outLen;
	mz_uint8* filters = NULL;
	mz_uint8* tempData = NULL;
	FILE* fptr = NULL;
	void* outBuffer = NULL;
	int i, offset, size;
	ccpng_color temp;

#ifdef _WIN32
	fopen_s(&fptr, filename, "wb");
#else
	fptr = fopen(filename, "wb");
#endif
	if( fptr != NULL )
	{
		// copy image
		size = height * width * (alpha ? 4 : 3);
		tempData = (mz_uint8*)MZ_MALLOC(sizeof(mz_uint8)*size);

		if( alpha == MZ_TRUE )
			memcpy(tempData,data,sizeof(mz_uint8)*size);
		else
			for(i = 0, offset = 0; i < size; ++offset, i += 3)
			{
				
				temp.c = data[offset];
				tempData[i+0] = temp.r;
				tempData[i+1] = temp.g;
				tempData[i+2] = temp.b;
			}

		if( filter == MZ_TRUE )
		{
			filters = (mz_uint8*)MZ_MALLOC(sizeof(mz_uint8)*height);
			CCPNGFilterImage( tempData, filters, width, height, alpha == MZ_TRUE ? 4 : 3 );
		}

		outBuffer = tdefl_write_image_to_png_file_in_memory_filters( tempData, filters, (int)width, (int)height, alpha == MZ_TRUE ? 4 : 3, &outLen);
		if( outBuffer != NULL )
		{
			fwrite( outBuffer, sizeof(char), outLen, fptr );
		}
		fclose(fptr);

		if( filter == MZ_TRUE )
			MZ_FREE(filters);

		MZ_FREE(outBuffer);
		MZ_FREE(tempData);
	}
}

#ifdef CCPNG_STANDALONE
unsigned int *GenRandom(unsigned int width,unsigned int height)
{
	unsigned int * pData = NULL;
	unsigned int pixels = width*height;
	unsigned int i;
	unsigned int alpha = 0xff000000;

	pData = (unsigned int*)malloc(sizeof(unsigned int)*pixels);

	for( i = 0; i < pixels; ++i )
	{
		pData[i] = 0;
		pData[i] |= alpha;
		pData[i] |= rand()%256;
		pData[i] |= rand()%256 << 8;
		pData[i] |= rand()%256 << 16;
	}

	return pData;
}

int main( int argc, char** argv )
{
	unsigned int width;
	unsigned int height;
	unsigned int* pData;

	CCPNGInit();
	if( argc > 2 )
	{
		pData = CCPNGReadFile(argv[1], &width, &height);

		if( pData != NULL )
		{
			CCPNGWriteFile(argv[2], pData, width, height, MZ_FALSE, MZ_TRUE);
			free(pData);
		}
	}
	else
	{
		printf("   usage: input.png output.png\n");
	}

	CCPNGDestroy();

	return 0;
}
#endif